

## Kmom02

Inom objektorientering har arv och komposition att göra med relationer mellan klasser. Arv innebär att man skapar en underklass från en basklass, vilket innebär att
underklassen "ärver" medlemsvariabler och metoder från basklassen. Detta görs generellt för att låta underklassen, den ärvande klassen, utöka eller specialisera basklassen.
Ett exempel skulle vara basklassen hund med underklasser (subklasser) för olika raser, där metoder läggs till eller skrivs över beroende på egenskaper hos varje ras. Inom PHP använder man nyckelordet "extends" när man vill att en klass ska ärva från en annan. Komposition å andra sidan påvisar en "har-en" relation, där en klass innehåller instanser av en annan klass. Komposition skiljer sig från t.ex. aggregation genom att det är en stark relation - när en objektinstans av föräldraklassen tas bort tas även instanserna som skapats inom objektet (barnobjekt) bort.

När det kommer till interface skiljer detta sig från enkelt arv från en basklass. Interface kan istället ses som ett kontrakt eller en innehållsförteckning av metoder för klasser som implementerar interfacet. Ett interface deklarerar metoder men definierar inte dem, de ges alltså ingen kod. Istället fungerar detta som en mall för klasser som implementerar interfacet i fråga - dessa klasser ska implementera metoderna genom att definiera dem. Interface används i PHP endast för metoder och inga medlemsvariabler deklareras. Interface skapas i PHP med nyckelordet interface och implementeras av en klass med nyckelordet implements. Sist men inte minst är traits ett sätt att i PHP implementera något som liknar multipelt arv, vilket i sin tur inte stöds i PHP enligt dess klassiska definition. Ett trait kan kortfattat ses som en återanvändbar kodmodul eller kodsnutt innehållande deklaration och definitioner av metoder och egenskaper som kan återanvändas över en eller flera klasser. I PHP deklareras ett trait med nyckelordet "trait" och används i en klass med nyckelordet "use". På så sätt kan en klass implementera en form av multipelt arv genom att istället för att ärva från flera klasser i klassdeklarationen använda/implementera flera traits. 

När det kommer till implementation av uppgiften började jag först med deklaration av klasserna Card, Deck, Hand och DeckWithJokers (varav den sista ärver från Deck). Än så länge har jag hållt dessa klasser relativt enkla med endast de uppgifter och metoder som krävs för att visa kort och ta bort och lägga till kort från kortlek och hand. Kort-klassen innehåller fyra medlemsvariabler, $suit (färg), $rank (värde i nummerform), $id (för lättare sortering) samt $img (filnamn för kort bilden). Därtill innehåller klassen två klasskonstanter i form av arrayer med strängrepresentationer av färg och kortnamn. Än så länge har jag endast implementerat en konstruktor i klassen och har hållt alla medlemsvariabler publika. Framöver kan jag dock tänkas implementera getters och setters med privata medlemsvariabler samt en metod för att hämta en strängrepresentation av kortet. Deck är likväl än så länge relativt enkel med endast en medlemsvariabel, $deck, innehållande kortleken samt en rad metoder, getCardSrc och getAllCardSrc för att hämta filnamn för ett eller samtliga kort; sorted för att sortera kortleken, shuffleDeck för att blanda kortleken, popCard för att ta bort det sista kortet i kortleken (det översta kortet) och getNumber för att räkna antal kort. DeckWithJokers ärver från Deck och skiljer sig att klassen i konstruktorn även lägger till två jokerkort. Sist men inte minst liknar Hand-klassen Deck i att den endast har en medlemsvariabel, $hand, som är en array av kort. Därtill har jag implementerat metoderna addCard och getAllCardSrc.

När det kommer till controllers har jag implementerat två stycken: CardController samt CardJsonController. CardController innehåller samtliga routes för kortleksfunktioner bortsett från JSON-api, som återfinns i CardJsonController. För varje kortleksroute kontrolleras först om en kortlek finns i session, om så används denna kortlek, annars skapas en ny kortlek. I routen /card/deck/shuffle/ skapas en ny kortlek oavsett för att nollställa denna. Samma sak gäller för klassen Hand i de routes där kort dras, där Hand fungerar här som en "korthög" med kort som dragits från kortleken. Först kontrolleras om en hand finns i sessionen, om inte så skapas en ny hand. Hand används ännu inte i routen där flera spelare tilldelas kort då jag här endast behöver filnamn på bilder, samt att kort tas bort från kortleken. Framöver är dock tanken att spelare ska representeras antingen av ett Hand-objekt eller av en ny spelar-klass innehållande ett Hand-objekt.

Då jag ännu endast implementerat det som krävs för att lösa uppgifterna för kursmoment finns det ännu mycket förbättringspotential i koden. Jag känner att jag har en bra bas att arbeta utifrån med kort- och kortleksklasserna, där potentiella problem lätt kommer kunna lösas genom att lägga till fler metoder. Samma gäller hand-klassen som framöver kommer att behöva utvidgas beroende på krav från de olika kortspelen. Därtill kommer jag att behöva implementera en spelarklass som innehåller en hand samt övriga medlemsvariabler för poängräkning och övrigt beroende på kortspel.

Då jag ännu inte börjat med kortspelen inom Kmom02 (jag väntar som rekommenderat med detta till Kmom03) kan jag ännu inte kommentera detta.

Det är för detta kursmoment svårt att tala om ett egentligt TIL eller ett läromoment som står ut över annat, utan det har kännts som en gradvis implementering av koncept som vi har lärt oss i tidigare kurser samt i kmom01 i ramverket symfony, t.ex. vad gäller routes och get/session. Det enda som stod ut och som jag inte stött på i någon form tidigare i andra programmeringsspråk är traits. Jag har tidigare använt mig av multipla arv vid deklaration av klasser, men detta var första gången jag hört talas om och använt mig av traits. Även interface är något som jag inte använt i alltför stor utsträckning, men begreppet i sig är bekant.