

## Metrics

### Introduktion
De fyra C:na, coverage, complexity, cohesion och coupling är viktiga indikatorer eller "metrics" när det kommer till att mäta kodkvalitet, detta gäller självklart också den kod som vi själva skrivit under kursen. 

Coverage, eller täckning, avser här kodtäckning för tester, det vill säga hur stor del av en kodbas som täcks av enhetstester. I ett idealt läge bör detta nummer vara så högt som möjligt, det vill säga 100%, men i vissa fall kan det anses vara överflödigt eller kanske till och me oönskvärt att lägga tid på enhetstester för mindre enheter där returresultat är garanterat. Kodtäckning är viktigt för att garantera att ens kod ej producerar buggar, varför det även är viktigt att testa uteliggane fall som potentiellt skulle orsaka fel. I mitt eget projekt uppnådde jag undder kmom04 100% testtäckning av den kod jag själv komponerat, exklusive controllers. När jag igen körde analysverktyget visade sig istället den faktiska kodtäckningen ligga på 26%, inklusive controllers, kernel.php samt av doctrine autogenererade filer. Detta innebär att det finns mycket utrymme att arbeta på och förbättra enhetstestning här.

Complexity, eller komplexitet, avser generellt cyklomatisk komplexitet för en funktion/metod eller klass. Cyklomatisk komplexitet i sin tur avser hur många beslutspunkter, det vill säga villkorssatser och loopar, eller hur många enskilda trådar som kan följas i en metod eller funktion. När det kommer till komplexitet är ett högt tall oönskvärt, då ökad komplexitet försvårar testning, då fler och kanske mer kompliceraded testfall måste undersökas, felsökning, underhåll och potentiellt ökar risken för buggar. I mitt eget projekt är detta den indikator som verkar visa på störst på problem. En metod i klassen CardGameController som sköter postförfrågningar har en cyklomatisk komplexitet på 13, vilket överstiger det ofta rekommenderade väret 10. Jag bestämde mig för att här sköta alla postförfrågningar från mitt kortspel i en och samma metod och route, vilket ökade komplexiteten och försvårar testning.

Cohesion, eller sammanhållning, är ett något svårare koncept att greppa. När det kommer till objektorienterad programmering innebär hög cohesion att alla metoder i en klass har bra sammanhållning och att en klass endast fokuserar på ett användsområde, medan låg cohesion betyder att en klass har för många och osammanhängande ansvarsområden och klassmetodder därutav har låg sammanhållning sinsemellan, de används för skilda saker. Låg cohesion kan tyda på kod där klassernas gränser inte är tydligt uttänkta och sköter allt för många saker på samma gång. Enligt PhpMetrics analys, där istället för Cohesion, mätvärdet "Lack of Cohesion" används, pekades flera klasser ut som klasser med mindre än optimal cohesion. Där 1 är optimal cohesion, dvs att alla metoder delar eller använder sig av samma resurs eller resurser, fick flera av mina klasser värdet 2. Vid närmare undersökning av klassen Deck visade det sig här dock vara ett felaktigt värde, då samtliga metoder på något sätt använde sig av den samm klassegenskap, en array av kort, och jag ej kunde hitta något som antydde på problem. Här kan det vara bra att notera att även om ett analysverktyg kan säga en sak kan s.k. "false positives" också finnas och att flera relaterade anvsarsområden ibland kan vara motiverade för en klass om dessa är relaterade och i de fall en klass används för att samla kod på ett logiskt sätt. Vid en titt på två andra klasser, LibraryController och CardGameController, som också fick värdet 2 i analysen är dessa svårare att analysera då dessa klasser snarare används för att samla relaterade routes. Detta att jämföra min kortklass som har ett stramt ansvarsområde: ett spelarkort.

När man talar om coupling talar man om sammankoppling av klasser, hur många klasser som en klass använder/känner till, (efferent coupling), och av hur många andra klasser klassen användds (afferent coupling). Coupling diskuteras ofta i samband med cohesion, där high cohesion och low coupling är önskvärt, där low coupling pekar på ett väldstrukturerat system där potentialla ändringar inte skapar alltför stora problem i samband med andra klasser, och där high cohesion hjälper till att göra en klass lättare att underhålla och förstå och är väl avgränsad. Motsatsen till detta skulle kunna leda till en klass med alltför många beroenden och alltför många ansvarsområden, ett s.k. "god object", vilket i sin tur kan innebära att kodden blir svåröversiktlig och svårunderhållen.
Vidare talas det i samband med coupling även om instabilitet, ett mätvärde mellan 0 och 1 som beräknas som en klass efferent coupling i förhållane till total koppling. Ett värde på 0 pekar på att klassen är helt stabil, den har inga beroenden och klasser beror istället på klassen. En sådan klass ska gärna hållas oförändrad så långt som möjligt pga av utåtgående beroenden. Ett värde på 1 pekar istället på en instabil klass, som måste ändras när klasser den är beroende på ändras medan inga andra klasser behöver ändras om klassen i fråga ändras. I Php Metrics pekades alla controllers ut som klasser med hög koppling och instabilitet, vilket kan förklararas av beroenden på inbyggda klasser i symfony och det faktum att inga andra klasser är beroende av dessa controllerklasser. Detta är dock ett bruksfall som ter sig vara oundvikligt med tanke på hur ramverket symfony fungerar. Vidare pekades klassen game ut som en klass med relativt hög instabilitet med efferent coupling på 3 och afferent coupling på 1, då denna klass samlar spelmekaniken för spelet och därför är beroende av övriga klasser relaterade till kortspelet.

### Phpmetrics
Med hjälp av analysverktyget PhpMetrics har jag analyserat min kodbas som jag använt under kursen enligt ovannämnnda fyra mätvärden, coverage, complexity, cohesion och coupling, samt size, dvs. storlek på klasserna. Om man börjar att titta på värdet coverage, dvs. hur mycket av koden som täcks av enhetstester har jag nått 100% täckning för de delar som vi behandlade i kmom04, men övriga klasser har utelämnats, dvs kontrollers samt av doctrine autogenererade filer. Här kan det finnas möjlighet att utöka enhetstestningen av controllers.

När det kommer till komplexitet har jag acceptabla värden under 10 för samtliga metoder med undantag för ovannämnda route-metod, GamePost, som hanterar POST-requests i klassen CardGameController. När det kommer till WMC, weighted method per class är medelvärdet 8.82, vilket får anses vara väl acceptabelt, dock så har klassen game ett värde på 33, CardController 21 och UserController 19. Dessa klasser och route-metoden för POST-requests kan vara värda att titta på för att reducera komplexiteten. I synnerhet metoden GamePost kan och kanske bör delas upp i flera routes och metoder som hanerar varsin POST-request. För både CardController och UserController tycks komplexitet bero på kontroller mot sessionvariabler för att se värden som finns i session och om variabler måste ställas in på nytt och inga av metoderna påvisar någon större cyklomatisk komplexitet, varför jag anser att dessa fall kan bortses ifrån. När det kommer till klassen game tycks det i sammanhanget högre WMC-värdet komma utav det faktum att klassen innehåller många småmetoder som adderar till värdet snarare än komplexa metoder. Då det mest logiska för detta fall var att samla alla metoder som krävs för spellogiken, i synnerhet då spelet i sig var relativt enkelt och det inte fanns någon god anledning att dela upp det i flera klasser, ser jag detta värde som acceptabelt. När det kommer mätvärdet class cyclomatic complexity har ovannämda tre klasser, tillsammans med klassen CardGameController värden på över 10. CardGameControllers relativa komplexitet kommer sig troligen av ovannämnda metod som bör överses.

När det kommer till cohesion, sammanhållning, har 5 klasser ett LCOM (lack of cohesion)-värde om 2: Deck, CardGameController, LibraryController, BookRepository och UserRepository. De två sistnämnda är autogenererade av Doctrine varför jag bortser från dem i denna analys. När det kommer till Deck-klassen har jag, som nämnts ovan, inte hittat någon anledning till varför cohesion värdet här är 2. Klassen har endast en klassegenskap, en array av kort, och samtliga metoder arbetar mot denna. När det kommer till de två controller-klasserna var det inte oväntat att några av dessa skulle ges cohesionvärden på över ett. Dessa klasser fungerar som samling metoder för att hantera relaterae routes och i enlighet med behoven för de olika sidorna använder de sig av olika resurser i klassen. Liksom nämnts ovan anser jag därför inte att cohesion är ett alltför relevant mätvärde att applicera på dessa klasser. Av övriga klasser fick 3 stycken klassen ett LCOM-värde på 0, entityklasser genererade av Doctrine samt kernel.php, medan alla andra klasser fick ett idealt LCOM-värde om 1, de har dvs identifierats som klasser som hanterar ett ansvarsområde.

Coupling är vid en första anblick ett problemområde för min kodbas, men när man tittar närmare är det framförallt controllerklasserna som är till synes problematiska. Som har förklarats ovan beror deras högre antal efferenta kopplingar (från 5 - 8) och höga instabilitet på 1 på det faktum att dessa klasser i stor utsträckning förlitar sig på och är beroene å funktionalitet och klasser som är inbyggda i symfony och dess extensions. Därtill har dessa klasser av dess natur inga afferenta kopplingar, vilket bidrar till dess höga instabilitet. I detta fall har jag kommit till slutsatsen att dessa mätvärden i mångt och mycket beror på hur ramverket symfony är uppbyggt och organiserat. Utöver dessa klasser har övriga klasser, enligt mig, acceptabla värden på efferenta kopplingar (0 - 3) och samtliga klasser med undantag för klassen deck har även afferenta kopplingar under tre (1-3). Klassen deck har 6 stycken afferenta kopplingar, vilket förklaras av att den används av samtliga kort-relaterade kontrollers som skapades under kursen samt till klassen game och genom arv till klassen DeckWithJokers. Dessa kopplingar anser jag vara oundvikliga i sammanhanget med tanke på hur de olika kursmomenten och uppgifterna byggts upp. När det kommer till instabilitet har två egendefinierae klasser hög instabilitet på över 0.5, Game och Deck with jokers. Dessa värden är beräknade på ett relativt lågt antal koppling (3 / 1 respektive 2 / 1) och kommer av naturen av klasserna. Game används bara av CardGameController-klassen, medan den använder sig av de andra olika kortklasserna som definierats, medan DeckWithJokers endast används av en kontrollerklass och har beroende till kort-klassen och genom arv till Deck-klassen. Dessa är återigen fall där jag inte ser något sätt att förbättra värdena.

När det kommer till size, storlek, dvs. antal rader kod, faller resultaten som väntat. Inga klasser är av ohanterlig storlek, med endast tre klasser över 100 rader logisk kod). De fem största klasserna är controllerklasser samt game-klassen. Av sin natur är controllerklasserna större då de samlar olika relaterade routes som används på hemsidan och då de sköter logik för att rendera hemsidan, kod som ofta är unik för sidan och som därför kan vara svår att bryta ut i ytterligare klasser och funktioner, vilket jag också tror skulle koden mer oöverskådlig. På samma sätt är gameklassen större än andra klasser då denna behöver hantera all logik för spelet. Även här ansåg jag det vara rimligt att samla all denna logik i en och samma klass i stället för att bryta ut i mindre klasser, något som skulle göra koden mer oöverskådlig och svårarbetad. Ett intressant mätvärde i sammanhanget var comment weight, eller hur stor andel av koden som är kommentarer. Flera av klasserna låg på mellan 40% och 50%, vilket kan förklaras av det faktum att klasserna i stor utsträckning består av småfunktioner som ej tar upp mycket plats, medan kommentarblocken för varje metod består av minst tre rader.

### Scrutinizer
Om man tar en titt på scrutinizer bör det nämnas att kodbasen, efter att ha filtrerat bort allt utanför src-katalogen, fick ett högt övergripande betyg om 9.84 av 10. 
I scrutinizer får jag liknande värden som phpmetrics, dvs. full täckning av tester för egendefinierade klasser, exklusive kontrollerklasser och komplexitet klasskomplexitet som stämmer övernens med ovannämnda WMC-värden, med 6 klasser med total klasskomplexitet på över 10 (Game: 34, CardController: 21, UserController: 19, CardGameController: 15, Player: 13 och Deck: 13). Av komplexitetsvärdena är det endast klassen game, med komplexitet om 34, som flaggas som gult, och därför kan anses vara värt att titta på. När man tittar närmare på metoderna är det endast ovannämnda metod GamePost, som hanterar post-routes för kortspelet, som har en cyklomatisk komplexitet över 10, vilket därför kan vara värt att titta på. Ytterligare en metod "DrawPlayerCards" i klassen CardController får betyg B av Scrutinizer pågrund av cyklomatisk komplexitet, men vid närmare granskning är alla villkorssatser och loopar som används i metoden nödvändiga. När det kommer till cohesion och coupling har jag likt vissa andra studenter inte fått några mätvärdena för detta i scrutinizer, varför jag måste hänvisa till ovan analys som gjorts utifrån phpmetrics resultat. Utöver dessa mätvärden finns endast ett mätvärde kvar som är av intresse i detta sammanhang, size/dublication, dvs. storlek och kodduplicering. Jag kan med nöje säga att ingen kodduplicering hittades för någon av de egenkomponerade klasserna, medan storlek återigen visar på liknande resultat som phpmetrics. De största klasserna är återigen tre kontrollerklasser: UserController med totalt 245 rader kod, Library Controller med 203 rader kod, CardController med 203 rader kod samt Game med 202 rader kod. Samtliga av de övriga klasserna har mindre än 100 rader kod.

När man tittar på specifika svagheter som kan förbättras rör dessa huvusakligen två områden: enhetstestning, där det kan vara relevant att implementera enhetstester för kontrollers, och kodkomplexitet, där metoden GamePost i klassen CardGameController bör brytas upp i separata metoder för de olika post-förfrågningarna. Därtill kan det vara värt att se om jag trots ovan analys kan få ner övergripane komplexitet i de klasser med högst total komplexitet, dvs. Game, CardController, UserController och kanske CardGameController (som påverkas av ovannämnda metod). Sist men inte minst har Scrutinizer identifierat 5 stycken issues, problem, i koden som kan orsaka buggar, en av dem i kernel.php som jag här ej kommer att röra, och fyra i min egen kod. Dessa fel är felstavat namespace, två fall där jag använder mig av villkorssatser av typ "if ($var)" för att kontrollera om en variabel är definierad och där striktare typkontroll bör specifieras, samt ett fall där jag överflödigt tilldelar returvärde från en set-metod till en variabel. Samtliga av dessa problem kan och bör korrigeras.




Skapa en rubrik “Scrutinizer” och analysera dess rapport för din kod. Hitta minst 3 svagheter som kan förbättras. Det kan vara samma som för phpmetrics eller nya. Huvudsaken är att du kan använda rapporten från Scrutinizer som stöd för att det är delar som behöver förbättras. Förutom 4C så skall du även hitta minst ett ytterligare mätvärde som du fann intressant hos Scrutinizer.

change in one module usually forces a ripple effect of changes in other modules.
Assembly of modules might require more effort and/or time due to the increased inter-module dependency.
A particular module might be harder to reuse and/or test because dependent modules must be included.