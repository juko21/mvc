

## Metrics

### Introduktion
De fyra C:na, coverage, complexity, cohesion och coupling är viktiga indikatorer eller "metrics" när det kommer till att mäta kodkvalitet, detta gäller självklart också den kod som vi själva skrivit under kursen. 

Coverage, eller täckning, avser här kodtäckning för tester, det vill säga hur stor del av en kodbas som täcks av enhetstester. I ett idealt läge bör detta nummer vara så högt som möjligt, det vill säga 100%, men i vissa fall kan det anses vara överflödigt eller kanske till och me oönskvärt att lägga tid på enhetstester för mindre enheter där returresultat är garanterat. Kodtäckning är viktigt för att garantera att ens kod ej producerar buggar, varför det även är viktigt att testa uteliggane fall som potentiellt skulle orsaka fel. I mitt eget projekt uppnådde jag undder kmom04 100% testtäckning av den kod jag själv komponerat, exklusive controllers. När jag igen körde analysverktyget visade sig istället den faktiska kodtäckningen ligga på 26%, inklusive controllers, kernel.php samt av doctrine autogenererade filer. Detta innebär att det finns mycket utrymme att arbeta på och förbättra enhetstestning här.

Complexity, eller komplexitet, avser generellt cyklomatisk komplexitet för en funktion/metod eller klass. Cyklomatisk komplexitet i sin tur avser hur många beslutspunkter, det vill säga villkorssatser och loopar, eller hur många enskilda trådar som kan följas i en metod eller funktion. När det kommer till komplexitet är ett högt tall oönskvärt, då ökad komplexitet försvårar testning, då fler och kanske mer kompliceraded testfall måste undersökas, felsökning, underhåll och potentiellt ökar risken för buggar. I mitt eget projekt är detta den indikator som verkar visa på störst på problem. En metod i klassen CardGameController som sköter postförfrågningar har en cyklomatisk komplexitet på 13, vilket överstiger det ofta rekommenderade väret 10. Jag bestämde mig för att här sköta alla postförfrågningar från mitt kortspel i en och samma metod och route, vilket ökade komplexiteten och försvårar testning.

Cohesion, eller sammanhållning, är ett något svårare koncept att greppa. När det kommer till objektorienterad programmering innebär hög cohesion att alla metoder i en klass har bra sammanhållning och att en klass endast fokuserar på ett användsområde, medan låg cohesion betyder att en klass har för många och osammanhängande ansvarsområden och klassmetodder därutav har låg sammanhållning sinsemellan, de används för skilda saker. Låg cohesion kan tyda på kod där klassernas gränser inte är tydligt uttänkta och sköter allt för många saker på samma gång. Enligt PhpMetrics analys, där istället för Cohesion, mätvärdet "Lack of Cohesion" används, pekades flera klasser ut som klasser med mindre än optimal cohesion. Där 1 är optimal cohesion, dvs att alla metoder delar eller använder sig av samma resurs eller resurser, fick flera av mina klasser värdet 2. Vid närmare undersökning av klassen Deck visade det sig här dock vara ett felaktigt värde, då samtliga metoder på något sätt använde sig av den samm klassegenskap, en array av kort, och jag ej kunde hitta något som antydde på problem. Här kan det vara bra att notera att även om ett analysverktyg kan säga en sak kan s.k. "false positives" också finnas och att flera relaterade anvsarsområden ibland kan vara motiverade för en klass om dessa är relaterade och i de fall en klass används för att samla kod på ett logiskt sätt. Vid en titt på två andra klasser, LibraryController och CardGameController, som också fick värdet 2 i analysen är dessa svårare att analysera då dessa klasser snarare används för att samla relaterade routes. Detta att jämföra min kortklass som har ett stramt ansvarsområde: ett spelarkort.

När man talar om coupling talar man om sammankoppling av klasser, hur många klasser som en klass använder/känner till, (efferent coupling), och av hur många andra klasser klassen användds (afferent coupling). Coupling diskuteras ofta i samband med cohesion, där high cohesion och low coupling är önskvärt, där low coupling pekar på ett väldstrukturerat system där potentialla ändringar inte skapar alltför stora problem i samband med andra klasser, och där high cohesion hjälper till att göra en klass lättare att underhålla och förstå och är väl avgränsad. Motsatsen till detta skulle kunna leda till en klass med alltför många beroenden och alltför många ansvarsområden, ett s.k. "god object", vilket i sin tur kan innebära att kodden blir svåröversiktlig och svårunderhållen.
Vidare talas det i samband med coupling även om instabilitet, ett mätvärde mellan 0 och 1 som beräknas som en klass efferent coupling i förhållane till total koppling. Ett värde på 0 pekar på att klassen är helt stabil, den har inga beroenden och klasser beror istället på klassen. En sådan klass ska gärna hållas oförändrad så långt som möjligt pga av utåtgående beroenden. Ett värde på 1 pekar istället på en instabil klass, som måste ändras när klasser den är beroende på ändras medan inga andra klasser behöver ändras om klassen i fråga ändras. I Php Metrics pekades alla controllers ut som klasser med hög koppling och instabilitet, vilket kan förklararas av beroenden på inbyggda klasser i symfony och det faktum att inga andra klasser är beroende av dessa controllerklasser. Detta är dock ett bruksfall som ter sig vara oundvikligt med tanke på hur ramverket symfony fungerar. Vidare pekades klassen game ut som en klass med relativt hög instabilitet med efferent coupling på 3 och afferent coupling på 1, då denna klass samlar spelmekaniken för spelet och därför är beroende av övriga klasser relaterade till kortspelet.

### Phpmetrics


Börja med en rubrik “Introduktion” där du förklarar de fyra C:na och hur de kan påverka kodens kvalitet. Exemplifiera med några mätvärden för de fyra C:na som är kopplade till din egen kod och ge en kort förklaring relaterad till kodkvalitet.


Skapa en rubrik “Phpmetrics” och analysera dess rapport för din kod. Använd 4C på utvalda delar av din kod och hitta minst ett ytterligare mätvärde som du väljer att ta upp. Använd mätvärdena för att hitta flaskhalsar och svaga punkter i din kod. Det vill alltså hitta koddelar som du kan uppdatera för att få bättre mätvärden.


change in one module usually forces a ripple effect of changes in other modules.
Assembly of modules might require more effort and/or time due to the increased inter-module dependency.
A particular module might be harder to reuse and/or test because dependent modules must be included.