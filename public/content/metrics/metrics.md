

## Metrics

### Introduktion
De fyra C:na, coverage, complexity, cohesion och coupling är viktiga indikatorer eller "metrics" när det kommer till att mäta kodkvalitet, detta gäller självklart också den kod som vi själva skrivit under kursen. 

Coverage, eller täckning, avser här kodtäckning för tester, det vill säga hur stor del av en kodbas som täcks av enhetstester. I ett idealt läge bör detta nummer vara så högt som möjligt, det vill säga 100%, men i vissa fall kan det anses vara överflödigt eller kanske till och me oönskvärt att lägga tid på enhetstester för mindre enheter där returresultat är garanterat. Kodtäckning är viktigt för att garantera att ens kod ej producerar buggar, varför det även är viktigt att testa uteliggane fall som potentiellt skulle orsaka fel. I mitt eget projekt uppnådde jag undder kmom04 100% testtäckning av den kod jag själv komponerat, exklusive controllers. När jag igen körde analysverktyget visade sig istället den faktiska kodtäckningen ligga på 26%, inklusive controllers, kernel.php samt av doctrine autogenererade filer. Detta innebär att det finns mycket utrymme att arbeta på och förbättra enhetstestning här.

Complexity, eller komplexitet, avser generellt cyklomatisk komplexitet för en funktion/metod eller klass. Cyklomatisk komplexitet i sin tur avser hur många beslutspunkter, det vill säga villkorssatser och loopar, eller hur många enskilda trådar som kan följas i en metod eller funktion. När det kommer till komplexitet är ett högt tall oönskvärt, då ökad komplexitet försvårar testning, då fler och kanske mer kompliceraded testfall måste undersökas, felsökning, underhåll och potentiellt ökar risken för buggar. I mitt eget projekt är detta den indikator som verkar visa på störst på problem. En metod i klassen CardGameController som sköter postförfrågningar har en cyklomatisk komplexitet på 13, vilket överstiger det ofta rekommenderade väret 10. Jag bestämde mig för att här sköta alla postförfrågningar från mitt kortspel i en och samma metod och route, vilket ökade komplexiteten och försvårar testning.

Cohesion, eller sammanhållning, är ett något svårare koncept att greppa. När det kommer till objektorienterad programmering innebär hög cohesion att alla metoder i en klass har bra sammanhållning och att en klass endast fokuserar på ett användsområde, medan låg cohesion betyder att en klass har för många och osammanhängande ansvarsområden och klassmetodder därutav har låg sammanhållning sinsemellan, de används för skilda saker. Låg cohesion kan tyda på kod där klassernas gränser inte är tydligt uttänkta och sköter allt för många saker på samma gång. Enligt PhpMetrics analys, där istället för Cohesion, mätvärdet "Lack of Cohesion" används, pekades flera klasser ut som klasser med mindre än optimal cohesion. Där 1 är optimal cohesion, dvs att alla metoder delar eller använder sig av samma resurs eller resurser, fick flera av mina klasser värdet 2. Vid närmare undersökning av klassen Deck visade det sig här dock vara ett felaktigt värde, då samtliga metoder på något sätt använde sig av den samm klassegenskap, en array av kort, och jag ej kunde hitta något som antydde på problem. Här kan det vara bra att notera att även om ett analysverktyg kan säga en sak kan s.k. "false positives" också finnas och att flera relaterade anvsarsområden ibland kan vara motiverade för en klass om dessa är relaterade och i de fall en klass används för att samla kod på ett logiskt sätt. Vid en titt på två andra klasser, LibraryController och CardGameController, som också fick värdet 2 i analysen är dessa svårare att analysera då dessa klasser snarare används för att samla relaterade routes. Detta att jämföra min kortklass som har ett stramt ansvarsområde: ett spelarkort.

När man talar om coupling talar man om sammankoppling av klasser, hur många klasser som en klass använder/känner till, (efferent coupling), och av hur många andra klasser klassen användds (afferent coupling). Coupling diskuteras ofta i samband med cohesion, där high cohesion och low coupling är önskvärt, där low coupling pekar på ett väldstrukturerat system där potentialla ändringar inte skapar alltför stora problem i samband med andra klasser, och där high cohesion hjälper till att göra en klass lättare att underhålla och förstå och är väl avgränsad. Motsatsen till detta skulle kunna leda till en klass med alltför många beroenden och alltför många ansvarsområden, ett s.k. "god object", vilket i sin tur kan innebära att kodden blir svåröversiktlig och svårunderhållen.
Vidare talas det i samband med coupling även om instabilitet, ett mätvärde mellan 0 och 1 som beräknas som en klass efferent coupling i förhållane till total koppling. Ett värde på 0 pekar på att klassen är helt stabil, den har inga beroenden och klasser beror istället på klassen. En sådan klass ska gärna hållas oförändrad så långt som möjligt pga av utåtgående beroenden. Ett värde på 1 pekar istället på en instabil klass, som måste ändras när klasser den är beroende på ändras medan inga andra klasser behöver ändras om klassen i fråga ändras. I Php Metrics pekades alla controllers ut som klasser med hög koppling och instabilitet, vilket kan förklararas av beroenden på inbyggda klasser i symfony och det faktum att inga andra klasser är beroende av dessa controllerklasser. Detta är dock ett bruksfall som ter sig vara oundvikligt med tanke på hur ramverket symfony fungerar. Vidare pekades klassen game ut som en klass med relativt hög instabilitet med efferent coupling på 3 och afferent coupling på 1, då denna klass samlar spelmekaniken för spelet och därför är beroende av övriga klasser relaterade till kortspelet.

### Phpmetrics
Med hjälp av analysverktyget PhpMetrics har jag analyserat min kodbas som jag använt under kursen enligt ovannämnnda fyra mätvärden, coverage, complexity, cohesion och coupling, samt size, dvs. storlek på klasserna. Om man börjar att titta på värdet coverage, dvs. hur mycket av koden som täcks av enhetstester har jag nått 100% täckning för de delar som vi behandlade i kmom04, men övriga klasser har utelämnats, dvs kontrollers samt av doctrine autogenererade filer. Här kan det finnas möjlighet att utöka enhetstestningen av controllers.

När det kommer till komplexitet har jag acceptabla värden under 10 för samtliga metoder med undantag för ovannämnda route-metod, GamePost, som hanterar POST-requests i klassen CardGameController. När det kommer till WMC, weighted method per class är medelvärdet 8.82, vilket får anses vara väl acceptabelt, dock så har klassen game ett värde på 33, CardController 21 och UserController 19. Dessa klasser och route-metoden för POST-requests kan vara värda att titta på för att reducera komplexiteten. I synnerhet metoden GamePost kan och kanske bör delas upp i flera routes och metoder som hanerar varsin POST-request. För både CardController och UserController tycks komplexitet bero på kontroller mot sessionvariabler för att se värden som finns i session och om variabler måste ställas in på nytt och inga av metoderna påvisar någon större cyklomatisk komplexitet, varför jag anser att dessa fall kan bortses ifrån. När det kommer till klassen game tycks det i sammanhanget högre WMC-värdet komma utav det faktum att klassen innehåller många småmetoder som adderar till värdet snarare än komplexa metoder. Då det mest logiska för detta fall var att samla alla metoder som krävs för spellogiken, i synnerhet då spelet i sig var relativt enkelt och det inte fanns någon god anledning att dela upp det i flera klasser, ser jag detta värde som acceptabelt. När det kommer mätvärdet class cyclomatic complexity har ovannämda tre klasser, tillsammans med klassen CardGameController värden på över 10. CardGameControllers relativa komplexitet kommer sig troligen av ovannämnda metod som bör överses.

När det kommer till cohesion, sammanhållning, har 5 klasser ett LCOM (lack of cohesion)-värde om 2: Deck, CardGameController, LibraryController, BookRepository och UserRepository. De två sistnämnda är autogenererade av Doctrine varför jag bortser från dem i denna analys. När det kommer till Deck-klassen har jag, som nämnts ovan, inte hittat någon anledning till varför cohesion värdet här är 2. Klassen har endast en klassegenskap, en array av kort, och samtliga metoder arbetar mot denna. När det kommer till de två controller-klasserna var det inte oväntat att några av dessa skulle ges cohesionvärden på över ett. Dessa klasser fungerar som samling metoder för att hantera relaterae routes och i enlighet med behoven för de olika sidorna använder de sig av olika resurser i klassen. Liksom nämnts ovan anser jag därför inte att cohesion är ett alltför relevant mätvärde att applicera på dessa klasser. Av övriga klasser fick 3 stycken klassen ett LCOM-värde på 0, entityklasser genererade av Doctrine samt kernel.php, medan alla andra klasser fick ett idealt LCOM-värde om 1, de har dvs identifierats som klasser som hanterar ett ansvarsområde.

Coupling är vid en första anblick ett problemområde för min kodbas, men när man tittar närmare är det framförallt controllerklasserna som är till synes problematiska. Som har förklarats ovan beror deras högre antal efferenta kopplingar (från 5 - 8) och höga instabilitet på 1 på det faktum att dessa klasser i stor utsträckning förlitar sig på och är beroene å funktionalitet och klasser som är inbyggda i symfony och dess extensions. Därtill har dessa klasser av dess natur inga afferenta kopplingar, vilket bidrar till dess höga instabilitet. I detta fall har jag kommit till slutsatsen att dessa mätvärden i mångt och mycket beror på hur ramverket symfony är uppbyggt och organiserat. Utöver dessa klasser har övriga klasser, enligt mig, acceptabla värden på efferenta kopplingar (0 - 3) och samtliga klasser med undantag för klassen deck har även afferenta kopplingar under tre (1-3). Klassen deck har 6 stycken afferenta kopplingar, vilket förklaras av att den används av samtliga kort-relaterade kontrollers som skapades under kursen samt till klassen game och genom arv till klassen DeckWithJokers. Dessa kopplingar anser jag vara oundvikliga i sammanhanget med tanke på hur de olika kursmomenten och uppgifterna byggts upp. När det kommer till instabilitet har två egendefinierae klasser hög instabilitet på över 0.5, Game och Deck with jokers. Dessa värden är beräknade på ett relativt lågt antal koppling (3 / 1 respektive 2 / 1) och kommer av naturen av klasserna. Game används bara av CardGameController-klassen, medan den använder sig av de andra olika kortklasserna som definierats, medan DeckWithJokers endast används av en kontrollerklass och har beroende till kort-klassen och genom arv till Deck-klassen. Dessa är återigen fall där jag inte ser något sätt att förbättra värdena.

När det kommer till size, storlek, dvs. antal rader kod, faller resultaten som väntat. Inga klasser är av ohanterlig storlek, med endast tre klasser över 100 rader logisk kod). De fem största klasserna är controllerklasser samt game-klassen. Av sin natur är controllerklasserna större då de samlar olika relaterade routes som används på hemsidan och då de sköter logik för att rendera hemsidan, kod som ofta är unik för sidan och som därför kan vara svår att bryta ut i ytterligare klasser och funktioner, vilket jag också tror skulle koden mer oöverskådlig. På samma sätt är gameklassen större än andra klasser då denna behöver hantera all logik för spelet. Även här ansåg jag det vara rimligt att samla all denna logik i en och samma klass i stället för att bryta ut i mindre klasser, något som skulle göra koden mer oöverskådlig och svårarbetad. Ett intressant mätvärde i sammanhanget var comment weight, eller hur stor andel av koden som är kommentarer. Flera av klasserna låg på mellan 40% och 50%, vilket kan förklaras av det faktum att klasserna i stor utsträckning består av småfunktioner som ej tar upp mycket plats, medan kommentarblocken för varje metod består av minst tre rader.

### Scrutinizer
Om man tar en titt på scrutinizer bör det nämnas att kodbasen, efter att ha filtrerat bort allt utanför src-katalogen, fick ett högt övergripande betyg om 9.84 av 10. 
I scrutinizer får jag liknande värden som phpmetrics, dvs. full täckning av tester för egendefinierade klasser, exklusive kontrollerklasser och komplexitet klasskomplexitet som stämmer övernens med ovannämnda WMC-värden, med 6 klasser med total klasskomplexitet på över 10 (Game: 34, CardController: 21, UserController: 19, CardGameController: 15, Player: 13 och Deck: 13). Av komplexitetsvärdena är det endast klassen game, med komplexitet om 34, som flaggas som gult, och därför kan anses vara värt att titta på. När man tittar närmare på metoderna är det endast ovannämnda metod GamePost, som hanterar post-routes för kortspelet, som har en cyklomatisk komplexitet över 10, vilket därför kan vara värt att titta på. Ytterligare en metod "DrawPlayerCards" i klassen CardController får betyg B av Scrutinizer pågrund av cyklomatisk komplexitet, men vid närmare granskning är alla villkorssatser och loopar som används i metoden nödvändiga. När det kommer till cohesion och coupling har jag likt vissa andra studenter inte fått några mätvärdena för detta i scrutinizer, varför jag måste hänvisa till ovan analys som gjorts utifrån phpmetrics resultat. Utöver dessa mätvärden finns endast ett mätvärde kvar som är av intresse i detta sammanhang, size/dublication, dvs. storlek och kodduplicering. Jag kan med nöje säga att ingen kodduplicering hittades för någon av de egenkomponerade klasserna, medan storlek återigen visar på liknande resultat som phpmetrics. De största klasserna är återigen tre kontrollerklasser: UserController med totalt 245 rader kod, Library Controller med 203 rader kod, CardController med 203 rader kod samt Game med 202 rader kod. Samtliga av de övriga klasserna har mindre än 100 rader kod.

När man tittar på specifika svagheter som kan förbättras rör dessa huvusakligen två områden: enhetstestning, där det kan vara relevant att implementera enhetstester för kontrollers, och kodkomplexitet, där metoden GamePost i klassen CardGameController bör brytas upp i separata metoder för de olika post-förfrågningarna. Därtill kan det vara värt att se om jag trots ovan analys kan få ner övergripane komplexitet i de klasser med högst total komplexitet, dvs. Game, CardController, UserController och kanske CardGameController (som påverkas av ovannämnda metod). Sist men inte minst har Scrutinizer identifierat 5 stycken issues, problem, i koden som kan orsaka buggar, en av dem i kernel.php som jag här ej kommer att röra, och fyra i min egen kod. Dessa fel är felstavat namespace, två fall där jag använder mig av villkorssatser av typ "if ($var)" för att kontrollera om en variabel är definierad och där striktare typkontroll bör specifieras, samt ett fall där jag överflödigt tilldelar returvärde från en set-metod till en variabel. Samtliga av dessa problem kan och bör korrigeras.

### Förbättringar

Den första förbättringen jag ämnar göra är att dela upp metoden GamePost i klassen CardGameController i flera separata funktioner som var för sig hanterar en post-route och en enskil post-förfrågan. Detta är det tydligaste problemet som jag hittat under min analys, och det problem där jag utan tvekan har åtgärder att tillämpa. Jag förutser att denna förbättring kommer att reducera maximal cyklomatisk komplexitet för metoder i klassen, men det kommer ej att reducera total komplexitet för klassen, eller potentiellt öka en något, då jag anser att villkorssatserna är nödvändiga för att säkerställa att rätt information har skickats med. Överlag ser jag dock detta som en förbättring då den leder till mer överskådlig och mer lättestad kod, trots den potentiellt höjda komplexiteten för klassen. 
 När det kommer 

Den andra förbättringen jag ämnar utföra är att gå vidare och titta på de två övriga controllerklasserna, CardController och UserController samt klassen Game, som har något förhöjd komplexitet i förhållande till övriga egenkomponerade klasser i projektet. I klassen Game skrev jag in möjligheten att skapa flera användare i en array, något som inte använts i spelet och därför kan tas bort, vilket i sin tur innebär att jag kan minska antalet beslutspunkter genom att ta bort for-loopar. Dessutom kan jag här förenkla en if sats som kontrollerar mot olika states (0 - 3) genom att istället kontrollera att stateargumentet som skickats med inte är mindre eller större än dessa vären. I klassen CardController har jag sparat undan dragna kort i ett handobjekt som sparas till session. Därför har jag också behövt ha villkorssatser som kontrollerar om variabeln är sparad, och om inte instansiera ett nytt objekt. Detta handobjekt kan jag ta bort helt och hållet från metoderna som använder det, då information aldrig hämtas härifrån. När det kommer till klassen UserController ser jag vid en närmare titt inga goda möjligheter att reducera dess komplexitet. Villkorssatser används här huvudsakligen för att kontrollera sessionsvariabler relaterade till inloggning, samt användarlösenord, varför dessa inte kan tas bort eller förenklas.

För min tredje förbättring hade jag gärna förbättrat kodtäckningen för enhetstester genom att inkludera kontrollerklasser, men jag kände att detta var orimligt för mig för detta kursmoment då detta ej berörts under kursen och då dessa är undantagna från både kmom04 och kmom10, och jag dessutom har haft svårighet att hitta bra och tydlig information om hur jag ska gå tillväga. Det hade helt enkelt tagit för mycket tid i sammanhanget. Detta är dock något jag ämnar lära mig på egen hand. Jag har istället beslutat att titta på efferventa kopplingar för samtliga klasser. Jag känner att det här kan finnas möjligheter att minska beroenden, t.ex. genom att använda mig av doctrines repositories direkt istället för att gå via entitymanager, så som förklarats i övningar. Jag identifierade även "use namespace"-satser för import av externa klasser som har följt med av misstag vid kopiering av filer. Det finns helt enkelt möjlighet att rensa upp. På så sätt tror jag att det är möjligt av få lösare kopplingar för i alla fall några av kontrollerfilerna.

Sist men inte minst har jag även tittat de 4 buggar eller problem som identifierats av scrutinizer i min kod, som nämnts ovan, och åtgärdat där det är relevant. Dessa är som följer: Felstavning av satsen "use symfony/asset" i kontrollerklassen ReportController. Denna klass används inte och satsen kan därför tas bort. Tilldelning av resultat från en set-metod till en variabel, där tillelningen kan tas bort; samt två fall där metoden password_veryify kallas i en villkorssats, med $user->get('password') som argument och ett fall där $user->get('email') skickas med som argument till en metod. Här påpekar scrutinizer att returvärdet från $user->get kan vara noll och därför kan behöva kontrollers. Jag kan dock här vara säker på att värdet existerar då det hämtas för en inloggad användare och då kolumnen password i databasen ej kan ta noll-värden. Därför väljer jag här att ej åtgärda problemet, vilket i sin tur skulle höja metodens komplexitet. Därtill har jag identifierat en oanvänd och oförklarlig import av klassen player i klassen deck som gav ett oresonligt lågt maintanence-betyg i PhpMetrics. Denna har tagits bort.

Efter att ha utfört ändringarna ser jag smärre men tydliga förbättringar i PhpMetrics. Där fem klasser identifierades som problematiska i mån av dess komplexitet och svårighet att underhålla, CardController med cyklomatisk komplexitet på 15, och maintainability index på 55,63; CardGameController på 13 respektive 64,8, Game med 13 respektive 73,15; UserController med 10 respektive 66,87 och Deck med 7 respektive 45,54. Fyra av dessa klasser lös rött på grund av sitt maintainability index. Efter refaktorering och avlägsning och förenkling av villkorssatser och loopar har dessa indikatorer förbättrats för samtliga klasser: CardController med komplexitet på 12 och maintainability index på 59,46; CardGameController på 13 respektive 70,36; Game med 9 respektive 75,55; UserController med 10 respektive 67,6 och Deck med 7 respektive 81,07. Överlag är det smärre förbättringar i betyg överlag, med förbättringar i cyklomatisk komplexitet på klassnivå för samtliga klasser förutom Game, där jag endast refaktorerade koden för minskad komplexitet på metodnivå, men annars hade samma eller högre komplexitet på klassnivå, och förbättringar i maintainability index för samtliga klasser och drastisk förbättring för klassen Deck, som hade en oanvänd klassimport. Man kan här fråga sig varför denna oanvända klassimport hade en så stor påverkan på betyget för klassen i fråga.

När man tittar på komplexitet specifikt har samtliga berörda klasser förutom UserController förbättrade WMC-värden, Game har gått från 33 till 29, CardController från 21 till 18 och CardGameController från 21 till 15. När det kommer till värdet "class cyclomatic complexity" har CardController gått från 15 till 12, Game har gått från 13 till 9, medan CardGameController och UserController är oförändrade på 13 respektive 10. Den tydligaste förändringen kan ses på metodnivå där max cyklomatisk komplexitet för metod har gått ner från 12 till 5 för klassen CardGameController till följd av refaktorering av metoden som hanterade samtliga post-förfrågningar för kortspelet. Dessutom har max metokomplexitet gått ner från 6 till 5 för CardController och 5 till 4 för Game. Dessa förändringar syns vidare på mätvärdet relativ systemkomplexitet, ett värde jag ej har diskuterat i denna rapport, där UserController, LibraryController och CardController har sett ganska drastiskt minskad komplexitet på 484,87 till 362, 289,68 till 196,81 respektive 121,7 till 100,77. För de två förstnämnda misstänker jag att denna förbättring av systemkomplexitet har att göra med av minskat antal kopplingar, där jag använder mig av repositoryklasser istället för att gå via ManagerRegistry-klassen i doctrine.

När det kommer till kopplingar ser jag något förbättrade värden, där UserController och LibraryController klasserna har minskat antal efferenta kopplingar från 8 till 7 och klassen CardController från 7 till 6. Klassen hands afferventa komplexitet har i sin tur minskat från 3 till 2 då kopplingen till denna klass har tagits bort från CardController. För UserController och LibraryController speglar det minskade antal kopplingarna bortkopplingen av klassen ManagerRegistry som används för att hämta en entityManager.

Vad gäller cohesion och coverage kan jag här ej se några förändringar i PhpMetrics, vilket är förväntat då jag ej berörde detta i mina förändringar.

Sist men inte minst har storleken på filerna minskat något för samtliga berörda filer förutom CardGameController som ökat från 78 rader till 119 rader på grund av refaktoreringen av klassen gamePost. Övriga berörda klasser har minskat med cirka 5 till 20 rader, UserController från 130 till 125, Game från 120 till 116, CardController från 134 till 115 och LibraryController från 88 till 83. Även om reducering av kodmängd kan tänkas vara till viss nytta när det kommer till att förutse överskådlighet och kodkomplexitet är det ett mycket grovhugget värde och andra värdena som komplexitet, cohesion och coupling är till synes betydligt mer användbara i sammanhanget. Med det sagt så följer den minskade kodmängden trenden med minskad komplexitet, men det är ett för grovhugget värde för att vara av till nytta i sammanhanget av detta projektet.

Om vi går vidare och tittar på scrutinizer bör det först nämnas att då jag ej får några cohesion och coupling-värden från scrutinizer kommer jag ej att beröra detta här, utan hänvisar till resultat från PhpMetrics ovan. Till att börja med det samlade betyget för projektet ökat från 9.84 till 10, vilket jag får anse vara ett gott betyg för förbättringarna. Komplexitet har som förväntat minskat för berörda klasser, i likhet med resultatet från PhpMetrics. Game har gått från 34 till 30, CardController har gått från 21 till 18, CardGameController har något oförväntat ökat från 15, 21, vilket kan ha att göra med det ökade antalet metoder, UserControler är oförändrad med 19, ReportController har ökat från 4 till 5 pga av inkludering av en metod för att hantera routen för denna rapport. På metodnivå flaggades två metoder med betyg på B och C, DrawPlayerCards respektive GamePost, detta på grund av sin cyklomatiska komplexitet på 6 respektive 12. Båda klasser får efter refaktorering A i betyg, med en minskning av komplexitet till 5 för DrawPlayerCards, tack vare borttagningen av ett handobjekt som lagras och hämtas från sessionen, och sedermera kontrolleras i en villkorssats, och en minskning till 5 för gamePost tack vare uppdelningen av metoden i flera routemetoder som var och en hanterar varsin post-förfrågan. Övriga klasser är oförändrade då de ej berörts av några större förändringar rörande komplexitet. 
 
 När det kommer till storlek ser man återigen liknande små förändringar med 202 till 198 för Game, 203 till 184 för CardController och 245 till 238 för UserController. CardGameController har som förväntat ökat från 97 till 203 rader kod på grund av faktoreringen, ReportController från 36 till 50 på grund av tillägg av denna route och Deck har något oförklarligen ökat från 48 till 65, trots att endast en rad har tagits bort, "use app/Player".

 Täckning av enhetstester är som förväntat oförändrad på kring 26% då inga större förändringar gjorts här.

### Diskussion

Användning av analysverktyg för att få en översikt av kodkvalitet och för att identifiera problem i koden är absolut något som kan och kanske bör implementeras i alla projekt av storlek, där det blir extra viktigt att bibehålla underhållningsbara klasser och kod, och framförallt att minska komplexitet för att underlätta testning och minska risken för buggar. Min erfarenhet i detta kursmoment har varit god och analysverktygen har hjälpt mig identifiera områden där jag kan förenkla koden, t.ex. genom faktorering av en metod till flera mindre metoder för att minska dess komplexitet och genom att identifiera överflödig kod och överflödiga importer, t.ex. i fallet med UserController och LibraryController, där jag kom fram till att jag ej behövde importera klassen ManagerRegistry, då de funktioner jag behövde härifrån kunde skötas av repositoryklasserna som skapats för de olika entities. Det sagt tror jag att det är viktigt att implementera användningen av dylika analysverktyg i ett projekt redan i ett tidigt stadium för att kunna nyttja dem löpande. Att applicera dem först när kodbasen är färdig eller kanske till och med halvfärdig känner jag lätt kan göra analysrapporterna svårare att ta sig igenom i synnerhet om man inte följt dem från ett tidigt stadium. Refaktorering av kod på ett sent stadium är vidare något som bör undvikas om möjligt då det kan innebära stora svårigheter, varför det återigen kan vara en god idé att applicera analysverktyg i ett tidigt skede. När det kommer till nackdelar rör detta framförallt tidsåtgång. När man ska analysera kod och eventuellt refaktorera den kan det vara relevant att fråga sig, behöver det göras? Är koden i fråga redan bevisat felfri, är det en liten kodbas, kommer den användas i stor utsträckning osv. Det kanske inte är helt relevant att börja analysera kod som man har kastat ihop för ett snabbt jobb som sedan stoppats undan, i synnerhet då en sådan analys och eventuell refaktorering kan ta en god stund att genomföra, tid som i många fall kan spenderas på annat arbete.
